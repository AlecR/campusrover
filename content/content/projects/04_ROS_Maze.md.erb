---
title: "Project: ROS Maze"
level: intermediate
---
#### Background
We now want to write a ROS node (or nodes) to drive the robot through a maze. You will do it first in simulation and then with the TB3.

#### Learning Objectives
* Demonstrate ability to write a multi node ROS app
* Examine some Maze solving algorithms
* Learn [PID algorithms](http://www.robotshop.com/letsmakerobots/pid-control), understand how they work, and implement one.
* Using laser distance sensor to sense maze walls
* Moving from simulated robot to actual robot

#### Reference
* ROS Book Chapter 7: "WanderBot"

#### Notes
You will not be using SLAM for this project. Instead you will use the Lidar to return to you distances to the next obstacle at different bearings. That way you can sense walls left, right and in front of you.

Notice that you will be writing and testing this algorithm in simulation mode. I think that the turtlesim is easier and faster than Gazebo but you will figure that out. When I say "blocks" below, I mean virtual blocks in simulation mode. Only when you can showo  your algoirthm working in sim mode will you get to try it on the real TB3.

As you write code, please try to think about good programming habits and designs. Your code may start as a bunch of spaghetti but by the time you hand it in we are expecting something with reasonable modularity, abstractions, single responsibility principle etc.


#### Steps
1. Using blocks create a short straight road with blocks on the left and the right. The beginning of the road is closed off as well with a block. Place the robot at that end of the road, and it should drive to the other end and stop. The way to think about this is that if you can detect walls on three sides, and  nothing on the fourth then you are at the start of the trip.
1. Turn the robot so that it is facing the open end of the road and begin moving. Use PID algorithms to stay in the middle of the path. Once you run out of right and left walls, you know you have arrived, so stop.
1. Next put a right turn in the road, so it is shaped like an "L", again with one closed end. This time you won't see a totally open end, but you will see clearly that the far end is well further. You will make some reasonable assumptions to tell the difference. Extend your straight line driver to detect the turn and make the turn, again until it is in open air, at which point you've reached the destination and you can stop.
1. Now create a dead end. When the robot comes to a dead end, with walls to the left, right and ahead, it should do a U-turn
1. Finally move on to an actual maze. While this is the "algorithm" part it is likely be the easiest. If you've gotten all the above to work RELIABLY then doing a maze is easy.

#### Competition
When everyone is done, with both mBot and TB3 maze runners we will have a competition!
